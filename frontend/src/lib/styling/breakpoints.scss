@use './types';
@use './units';

$debug: false !default;
$breakpoints: (
	small: 0px,
	medium: 640px,
	large: 1024px,
	xlarge: 1200px,
	xxlarge: 1440px
) !default;

$zero: small !default;
$keys: types.map-to-list($breakpoints, 'keys');

/// All of the names in this list will be output as classes in your CSS, like `.small-12`, `.medium-6`, and so on. Each value in this list must also be in the `$breakpoints` map.
/// @type List
$classes: (small medium large) !default;

// TODO: Handle this after first value check
// Might need to return in if check?
@use 'mq' with (
	$breakpoints: $breakpoints,
	$show-breakpoints: if($debug == true, $keys, ())
);

@forward 'mq';

@if nth(map-values($breakpoints), 1) != 0px {
	@error 'The first key in the $breakpoints map must have a value of "0".';
} @else {
	$zero: nth(map-keys($breakpoints), 1);
}

//
// Functions
//

/// Return a list of our named breakpoints less than $key. Useful for dealing with
/// responsive gutters for the grid.
/// @access private
///
/// @param {String} $breakpoint - a named or non-named breakpoint.
///
/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero
@function closestNamedBreakpoint($breakpoint) {
	$last: $zero;
	$found: false;

	$value: units.unitlessCalc($breakpoint, 1px);
	@each $key, $val in $breakpoints {
		@if not $found {
			@if units.unitlessCalc($val) > $value {
				$found: true;
			} @else {
				$last: $key;
			}
		}
	}

	@return $last;
}

//
/// Get a value for a breakpoint from a responsive config map or single value.
/// - If the config is a single value, return it regardless of `$value`.
/// - If the config is a map and has the key `$value`, the exact breakpoint value is returned.
/// - If the config is a map and does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned.
/// @access private
///
/// @param {Number|Map} $map - Responsive config map or single value.
/// @param {Keyword} $value - Breakpoint name to use.
///
/// @return {Mixed} The corresponding breakpoint value.
@function getBreakpointValue($map, $value) {
	// If the given map is a single value, return it
	@if type-of($map) == 'number' {
		@return $map;
	}

	// Check if the breakpoint name exists globally
	@if not map-has-key($breakpoints, $value) {
		@if type-of($value) == 'number' {
			$value: closestNamedBreakpoint($value);
		} @else {
			@return null;
		}
	}
	// Check if the breakpoint name exists in the local config map
	@else if map-has-key($map, $value) {
		// If it does, just return the value
		@return map-get($map, $value);
	}
	// Otherwise, find the next lowest breakpoint and return that value
	@else {
		$anchor: null;
		$found: false;

		@each $key, $val in $breakpoints {
			@if not $found {
				@if map-has-key($map, $key) {
					$anchor: $key;
				}
				@if $key == $value {
					$found: true;
				}
			}
		}

		@return map-get($map, $anchor);
	}
}

@mixin breakpoint($size) {
	@if ($size == $zero) {
		@content ($size);
	} @else {
		@include mq.mq($from: $size) {
			@content ($size);
		}
	}
}

/// Iterates through breakpoints defined in `$breakpoint-classes` and prints the CSS inside the mixin at each breakpoint's media query. Use this with the grid, or any other component that has responsive classes.
///
/// @param {Boolean} $small [true] - If `false`, the mixin will skip the `small` breakpoint. Use this with components that don't prefix classes with `small-`, only `medium-` and up.
/// @param {Boolean} $auto-insert-breakpoints [true] - If `false`, the mixin will iterate over breakpoints without doing the media query itself. Useful for more complex media query generation as in the margin grid.
@mixin eachBreakpoint {
	@each $size in $classes {
		@include breakpoint($size) using ($size) {
			@content ($size);
		}
	}
}

/// Generate the `@content` passed to the mixin with a value `$-zf-bp-value` related to a breakpoint, depending on the `$name` parameter:
/// - For a single value, `$-zf-bp-value` is this value.
/// - For a breakpoint name, `$-zf-bp-value` is the corresponding breakpoint value in `$map`.
/// - For "auto", `$-zf-bp-value` is the corresponding breakpoint value in `$map` and is passed to `@content`, which is made responsive for each breakpoint of `$map`.
/// @param {Number|Array|Keyword} $name [auto] - Single value, breakpoint name, or list of breakpoint names to use. "auto" by default.
/// @param {Number|Map} $map - Map of breakpoints and values or single value to use.
// @mixin breakpointValue(
//   $name: auto,
//   $map: null
// ) {
//   @if $name == auto and type-of($map) == 'map' {
//     // "auto"
//     @each $k, $v in $map {
//       @include breakpoint($k) {
//         @include breakpointValue($v, $map) {
//           @content;
//         }
//       }
//     }
//   }
//   @else {
//     // breakpoint name
//     @if type-of($name) == 'string' {
//       $bp-value: getBreakpointValue($map, $name);
//       @if $bp-value != null {
//         $name: $bp-value;
//       }
//     }

//     // breakpoint value
//     $-global-bp-value: $name !global;
//     @content;
//   }
// }
